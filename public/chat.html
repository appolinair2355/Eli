<!DOCTYPE html><html lang="fr">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Kouam√© AI ‚Äì G√©n√©rateur d‚Äôhistoires (v2)</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <style>
    body { font-family: Arial, Helvetica, sans-serif; margin: 0; padding: 20px; background: #121212; color: #fff; }
    h1 { text-align: center; margin-bottom: 20px; }
    .form-row { display: flex; gap: 10px; margin-bottom: 15px; }
    input, textarea { width: 100%; padding: 10px; border: none; border-radius: 6px; font-size: 16px; }
    input { background: #1f1f1f; color: #fff; }
    textarea { background: #1f1f1f; color: #fff; resize: vertical; }
    #summary { height: 120px; }
    #consignes { height: 150px; }
    .btn-row { margin-top: 15px; display: flex; gap: 10px; flex-wrap: wrap; align-items:center; }
    button { background: #007bff; border: none; border-radius: 6px; color: white; padding: 12px 18px; font-size: 16px; cursor: pointer; }
    button:hover { background: #0056b3; }
    #minWords, #episodesCount, #wordsPerEpisode { width: 140px; background: #1f1f1f; color: #fff; }
    #result { margin-top: 20px; padding: 20px; background: #1e1e1e; border-radius: 8px; line-height: 1.6; white-space: pre-wrap; }
    #result h2, #result h3 { color: #00bfff; }
    #result strong { color: #ffcc00; }
    #result em { color: #ffaaff; }
    .signature { margin-top: 15px; font-size: 14px; color: #aaa; text-align: right; }
    #history { margin-top: 30px; padding: 15px; background: #1a1a1a; border-radius: 8px; }
    #history h2 { margin-top: 0; color: #ffcc00; }
    #history ul { list-style: none; padding: 0; margin: 0; }
    #history li { padding: 8px; margin: 5px 0; background: #2a2a2a; border-radius: 5px; cursor: pointer; }
    #history li:hover { background: #444; }
    #exportBtn { margin-top: 15px; background: #28a745; }
    #exportBtn:hover { background: #1e7e34; }
    .btn-modify { background: #ffc107; color: #000; }
    .btn-modify:hover { background: #e0a800; }
    .small { font-size: 13px; color:#bbb; }
  </style>
</head>
<body>
  <h1>üìñ G√©n√©rateur d‚Äôhistoires ‚Äì Kouam√© AI (v2)</h1>  <!-- Ligne titre / √©pisode / auteur -->  <div class="form-row">
    <input id="title" type="text" placeholder="Titre de l‚Äôhistoire">
    <input id="episode" type="number" placeholder="√âpisode (pour g√©n√©ration simple)">
    <input id="author" type="text" placeholder="Auteur">
  </div>  <!-- R√©sum√© initial --><label for="summary">R√©sum√© de base (pr√©sentation des personnages et contexte) :</label>

  <textarea id="summary" placeholder="D√©crivez vos personnages, univers et contexte de d√©part..."></textarea>  <!-- Zone de consignes --><label for="consignes">Consignes / Modifications :</label>

  <textarea id="consignes" placeholder="Laissez vide pour que l‚ÄôIA continue seule, ou √©crivez vos consignes ici..."></textarea>  <!-- Ligne boutons -->  <div class="btn-row">
    <button onclick="generateStory()">Ai Kouam√© g√©n√©r√©</button>
    <input id="minWords" type="number" placeholder="N (mots min)">
    <button onclick="nextEpisode()">√âpisode suivant</button>
    <button onclick="editEpisode()" class="btn-modify">‚úèÔ∏è Modifier √©pisode</button>
    <button onclick="styleStory()">S</button>
    <button onclick="resetStory()" style="background:#dc3545;">üîÑ R√©initialiser</button><!-- Nouvelle section : g√©n√©ration automatique en s√©rie -->
<input id="episodesCount" type="number" placeholder="Nombre d'√©pisodes (min 15)" value="15">
<input id="wordsPerEpisode" type="number" placeholder="Mots par √©pisode" value="300">
<button id="seriesBtn" onclick="generateSeries()">üì∫ G√©n√©rer s√©rie</button>

  </div>  <!-- R√©sultat -->  <div id="result"></div>  <!-- Historique -->  <div id="history">
    <h2>üìö Historique des √©pisodes</h2>
    <ul id="historyList"></ul>
    <button id="exportBtn" onclick="exportPDF()">üì• Exporter en PDF</button>
  </div>  <script>
    const resultDiv = document.getElementById("result");
    const historyList = document.getElementById("historyList");
    let lastStory = "";
    let storyHistory = [];

    // ---------- Utilitaires ----------
    function stripHtml(html) {
      const tmp = document.createElement('div');
      tmp.innerHTML = html;
      return tmp.textContent || tmp.innerText || '';
    }

    function countWords(text) {
      if (!text) return 0;
      return (text.trim().split(/\s+/).filter(Boolean)).length;
    }

    function saveData() {
      const data = {
        title: document.getElementById("title").value,
        episode: document.getElementById("episode").value,
        author: document.getElementById("author").value,
        summary: document.getElementById("summary").value,
        history: storyHistory,
        result: resultDiv.innerHTML
      };
      localStorage.setItem("storyData", JSON.stringify(data));
      console.log('Donn√©es sauvegard√©es', data);
    }

    function loadData() {
      const saved = localStorage.getItem("storyData");
      if (!saved) return;
      const data = JSON.parse(saved);
      document.getElementById("title").value = data.title || "";
      document.getElementById("episode").value = data.episode || "";
      document.getElementById("author").value = data.author || "";
      document.getElementById("summary").value = data.summary || "";
      storyHistory = data.history || [];
      resultDiv.innerHTML = data.result || "";
      renderHistory();
    }

    window.onload = loadData;
    window.onbeforeunload = saveData;

    function renderHistory() {
      historyList.innerHTML = "";
      storyHistory.forEach((ep) => {
        const li = document.createElement("li");
        li.textContent = ep.title + " ‚Äì √âpisode " + ep.episode + " (" + countWords(ep.fullText) + " mots)";
        li.onclick = () => { resultDiv.innerHTML = ep.content; lastStory = ep.fullText; };
        historyList.appendChild(li);
      });
    }

    // ---------- Communication avec le serveur (helper pour g√©n√©ration) ----------
    async function fetchStreamedAnswer(prompt, onChunk) {
      console.log('fetchStreamedAnswer prompt:', prompt.slice(0,120));
      const res = await fetch("/ask", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ data: "", question: prompt })
      });
      if (!res.ok) {
        const txt = await res.text();
        throw new Error('Erreur API: ' + res.status + ' ' + txt);
      }
      const reader = res.body.getReader();
      const decoder = new TextDecoder();
      let text = "";
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        const chunk = decoder.decode(value, { stream: true });
        text += chunk;
        if (onChunk) onChunk(chunk, text);
      }
      return text;
    }

    // ---------- G√©n√©ration d'un √©pisode (utilis√© par g√©n√©ration simple et s√©rie) ----------
    async function generateSingleEpisode({episodeNumber, prevEpisodesText, minWords, title, author, summary, consignes, displayProgress}) {
      const maxExtraAttempts = 3;
      let attempt = 0;
      let episodeText = "";

      while (attempt <= maxExtraAttempts) {
        attempt++;
        const prompt = `Titre : ${title}\n√âpisode ${episodeNumber}\nAuteur : ${author}\n\nR√©sum√© initial : ${summary}\n\n` +
          (prevEpisodesText ? `Texte complet des √©pisodes pr√©c√©dents :\n${prevEpisodesText}\n\n` : '') +
          (consignes ? `Consignes pour cet √©pisode : ${consignes}\n\n` : `Continue naturellement l‚Äôhistoire avec coh√©rence et √©volution des √©v√©nements.\n\n`) +
          `Contraintes :\n- √âcris UNIQUEMENT le contenu de l'√©pisode ${episodeNumber} (pas de titre ni num√©ro).\n- Respecte la continuit√© et fais avancer l'intrigue clairement.\n- Minimum ${minWords} mots pour cet √©pisode.\n- Style narratif riche : d√©cor, sensations, dialogues, √©motions.\n- R√©ponds uniquement avec le texte de l'√©pisode, sans pr√©face ni ast√©risque.\n`;

        resultDiv.textContent = (displayProgress ? `G√©n√©ration √©pisode ${episodeNumber} (tentative ${attempt})...` : 'G√©n√©ration en cours...');
        try {
          const streamed = await fetchStreamedAnswer(prompt, (chunk, fullSoFar) => {
            // streaming preview (non-final)
            resultDiv.textContent = (displayProgress ? `√âpisode ${episodeNumber} ‚Äî g√©n√©ration en cours...` : '...');
          });

          episodeText = streamed.trim();
          console.log(`Episode ${episodeNumber} - tentative ${attempt} mots:`, countWords(episodeText));

          // Si le mod√®le a r√©pondu en incluant "√âpisode X" ou titres, on essaie de nettoyer
          episodeText = episodeText.replace(/^\s*√âpisode\s*\d+\s*[:\-‚Äì]?\s*/i, '');

          // V√©rifier la longueur
          const words = countWords(stripHtml(episodeText));
          if (words >= minWords) {
            return episodeText;
          } else {
            // Demander une continuation cibl√©e pour atteindre le nombre de mots demand√©
            if (attempt <= maxExtraAttempts) {
              const need = minWords - words;
              const contPrompt = `Voici le d√©but de l'√©pisode ${episodeNumber} (texte actuel) :\n\n${episodeText}\n\n` +
                `Le texte ci-dessus comporte ${words} mots. D√©veloppe et poursuis cet √©pisode pour atteindre au moins ${minWords} mots en gardant le m√™me ton et la m√™me continuit√©. N'ajoute pas de titre ni de num√©ro d'√©pisode et ne r√©p√®te pas le texte d√©j√† pr√©sent. Continue directement √† la suite.`;
              resultDiv.textContent = (displayProgress ? `Episode ${episodeNumber} ‚Äî extension (essai ${attempt})...` : '...');
              const extra = await fetchStreamedAnswer(contPrompt, (chunk) => {
                // we won't stream the extra in full to the UI to avoid flicker; show a small notice
                resultDiv.textContent = (displayProgress ? `Episode ${episodeNumber} ‚Äî extension en cours...` : '...');
              });
              // Append the extra to episodeText and continue the loop to re-evaluate
              episodeText = (episodeText + '\n' + extra).trim();
              console.log(`Episode ${episodeNumber} apr√®s extension ${attempt} mots:`, countWords(stripHtml(episodeText)));
              // continue the while loop to check again
            } else {
              // Max attempts reached ‚Äî return what we have
              console.warn(`Episode ${episodeNumber} n'a pas atteint ${minWords} mots apr√®s ${attempt} tentatives.`);
              return episodeText;
            }
          }

        } catch (err) {
          console.error('Erreur pendant la g√©n√©ration:', err);
          throw err;
        }
      }
      return episodeText;
    }

    // ---------- G√©n√©ration simple (un √©pisode) ----------
    async function generateStory() {
      const title = document.getElementById("title").value.trim();
      const episode = document.getElementById("episode").value.trim();
      const author = document.getElementById("author").value.trim();
      const summary = document.getElementById("summary").value.trim();
      const consignes = document.getElementById("consignes").value.trim();
      const minWords = parseInt(document.getElementById("minWords").value) || 0;

      if (!title || !episode || !author) { alert("Veuillez remplir Titre, √âpisode et Auteur !"); return; }

      try {
        const prev = storyHistory.map(e => `--- √âpisode ${e.episode} ---\n${e.fullText}`).join('\n\n');
        const epText = await generateSingleEpisode({ episodeNumber: episode, prevEpisodesText: prev, minWords: Math.max(0,minWords), title, author, summary, consignes, displayProgress: true });

        lastStory = epText;
        const fullContent = `<h2>${title}</h2><h3>√âpisode ${episode}</h3><div>${epText}</div><div class="signature">Auteur : ${author}<br>D√©veloppeur : Sossou Kouam√©</div>`;
        resultDiv.innerHTML = fullContent;

        storyHistory.push({ title, episode, preview: epText.slice(0,100)+"...", content: fullContent, fullText: epText });
        renderHistory(); saveData();
        document.getElementById("consignes").value = "";
      } catch (err) {
        alert('Erreur lors de la g√©n√©ration : ' + err.message);
      }
    }

    // ---------- G√©n√©ration s√©rie (nouveau bouton) ----------
    async function generateSeries() {
      const title = document.getElementById("title").value.trim();
      const author = document.getElementById("author").value.trim();
      const summary = document.getElementById("summary").value.trim();
      const consignes = document.getElementById("consignes").value.trim();
      let episodesCount = parseInt(document.getElementById("episodesCount").value) || 0;
      const wordsPerEpisode = parseInt(document.getElementById("wordsPerEpisode").value) || 200;

      if (!title || !author) { alert("Veuillez remplir Titre et Auteur !"); return; }
      if (episodesCount < 15) episodesCount = 15; // forcer minimum 15

      // On va g√©n√©rer √©pisode par √©pisode pour garder la continuit√© et respecter le nombre de mots
      let prevText = storyHistory.map(e => `--- √âpisode ${e.episode} ---\n${e.fullText}`).join('\n\n');

      for (let i = 1; i <= episodesCount; i++) {
        try {
          resultDiv.textContent = `üì∫ G√©n√©ration s√©rie ‚Äî √©pisode ${i} / ${episodesCount}...`;
          console.log(`G√©n√©ration s√©rie: √©pisode ${i}`);

          const epText = await generateSingleEpisode({ episodeNumber: i, prevEpisodesText: prevText, minWords: wordsPerEpisode, title, author, summary, consignes, displayProgress: true });

          lastStory = epText;
          const fullContent = `<h2>${title}</h2><h3>√âpisode ${i}</h3><div>${epText}</div><div class="signature">Auteur : ${author}<br>D√©veloppeur : Sossou Kouam√©</div>`;

          storyHistory.push({ title, episode: i, preview: epText.slice(0,100)+"...", content: fullContent, fullText: epText });
          prevText += `\n\n--- √âpisode ${i} ---\n${epText}`;
          renderHistory(); saveData();

          // Afficher l'√©pisode g√©n√©r√© dans l'interface
          resultDiv.innerHTML = fullContent;
        } catch (err) {
          console.error('Erreur g√©n√©ration s√©rie √©pisode', i, err);
          alert('Erreur lors de la g√©n√©ration de la s√©rie (√©pisode ' + i + '): ' + err.message);
          break;
        }
      }

      // Vider consignes apr√®s g√©n√©ration en s√©rie
      document.getElementById("consignes").value = "";
    }

    // ---------- Modifier √©pisode (prompt renforc√©) ----------
    async function editEpisode() {
      if (!lastStory) { alert("Aucun √©pisode √† modifier !"); return; }
      const consignes = document.getElementById("consignes").value.trim();
      if (!consignes) { alert("√âcrivez vos consignes de modification !"); return; }
      const title = document.getElementById("title").value.trim();
      const episode = document.getElementById("episode").value.trim();
      const author = document.getElementById("author").value.trim();

      // Prompt plus strict pour √©viter que l'IA modifie autre chose
      const editPrompt = `Voici le texte original de l'√©pisode ${episode} de l'histoire "${title}" :\n\n${lastStory}\n\n` +
        `Consignes de modification (applique uniquement ces changements et RIEN d'autre) : "${consignes}".\n` +
        `Contraintes strictes :\n- Ne modifie pas les noms des personnages ni leur histoire de fond, sauf si la consigne le demande explicitement.\n- Ne rajoute pas de titre ni de num√©ro d'√©pisode.\n- Ne commente pas tes changements ; retourne uniquement le texte modifi√©.\n- Garde le style et la coh√©rence narrative.\n`;

      resultDiv.textContent = "‚úèÔ∏è Application des modifications‚Ä¶";
      try {
        const modified = await fetchStreamedAnswer(editPrompt, (chunk, full) => {
          resultDiv.textContent = '‚úèÔ∏è Modification en cours...';
        });

        lastStory = modified.trim();

        // Mettre √† jour dans l'historique si l'√©pisode existe
        const existing = storyHistory.find(ep => String(ep.episode) === String(episode));
        if (existing) {
          existing.fullText = lastStory;
          existing.preview = lastStory.slice(0,100)+"...";
          existing.content = `<h2>${title}</h2><h3>√âpisode ${episode}</h3><div>${lastStory}</div><div class="signature">Auteur : ${author}<br>D√©veloppeur : Sossou Kouam√©</div>`;
          resultDiv.innerHTML = existing.content;
        } else {
          // si √©pisode pas trouv√©, on l'ajoute
          const fullContent = `<h2>${title}</h2><h3>√âpisode ${episode}</h3><div>${lastStory}</div><div class="signature">Auteur : ${author}<br>D√©veloppeur : Sossou Kouam√©</div>`;
          storyHistory.push({ title, episode, preview: lastStory.slice(0,100)+"...", content: fullContent, fullText: lastStory });
          resultDiv.innerHTML = fullContent;
        }

        renderHistory(); saveData();
        document.getElementById("consignes").value = "";
      } catch (err) {
        alert('Erreur lors de la modification : ' + err.message);
      }
    }

    async function nextEpisode() {
      const epInput = document.getElementById("episode");
      epInput.value = parseInt(epInput.value||"0")+1;
      await generateStory();
    }

    async function styleStory() {
      if (!lastStory) { alert("G√©n√©rez d‚Äôabord une histoire !"); return; }
      const stylePrompt = `R√©√©cris ce texte avec style (gras, italique, emojis), sans changer le sens ni rajouter titre ou num√©ro :\n${lastStory}`;
      resultDiv.textContent = "‚ú® Application du style‚Ä¶";
      try {
        const styled = await fetchStreamedAnswer(stylePrompt, (chunk) => {
          resultDiv.textContent = '‚ú® Application du style en cours...';
        });
        lastStory = styled;
        const episode = document.getElementById("episode").value.trim(); const title = document.getElementById("title").value.trim(); const author = document.getElementById("author").value.trim();
        const existing = storyHistory.find(ep => String(ep.episode) === String(episode));
        if (existing) { existing.fullText = styled; existing.preview = styled.slice(0,100)+"..."; existing.content = `<h2>${title}</h2><h3>√âpisode ${episode}</h3><div>${styled}</div><div class="signature">Auteur : ${author}<br>D√©veloppeur : Sossou Kouam√©</div>`; resultDiv.innerHTML = existing.content; }
        renderHistory(); saveData();
      } catch (err) { alert('Erreur lors du styling : ' + err.message); }
    }

    function resetStory() {
      if (!confirm("Voulez-vous vraiment r√©initialiser l‚Äôhistoire ?")) return;
      localStorage.removeItem("storyData");
      document.getElementById("title").value=""; document.getElementById("episode").value=""; document.getElementById("author").value=""; document.getElementById("summary").value=""; document.getElementById("consignes").value="";
      resultDiv.innerHTML=""; historyList.innerHTML=""; storyHistory=[]; lastStory="";
    }

    // ---------- Export PDF (correction : utiliser texte nettoy√©) ----------
    async function exportPDF() {
      if (storyHistory.length===0) { alert("Aucune histoire √† exporter !"); return; }
      const { jsPDF } = window.jspdf; const doc = new jsPDF(); let y=30;
      const title=document.getElementById("title").value||"Mon Histoire"; const author=document.getElementById("author").value||"Inconnu"; const summary=document.getElementById("summary").value||"Pas de r√©sum√©";
      doc.setFontSize(24); doc.setTextColor(30,144,255); doc.text(title,105,y,{align:"center"}); y+=20;
      doc.setFontSize(16); doc.setTextColor(0,0,0); doc.text("Auteur : "+author,105,y,{align:"center"}); y+=20;
      doc.setFontSize(14); doc.setTextColor(80,80,80); const summaryLines=doc.splitTextToSize("R√©sum√© : "+summary,170); doc.text(summaryLines,20,y); doc.addPage();
      y=20;
      storyHistory.forEach((ep)=>{
        doc.setFontSize(16); doc.setTextColor(255,69,0); doc.text(`√âpisode ${ep.episode}`,20,y); y+=10;
        doc.setFontSize(12); doc.setTextColor(0,0,0);
        const 
