<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Kouam√© AI ‚Äì G√©n√©rateur d‚Äôhistoires</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <style>
    :root{
      --bg:#121212; --card:#1e1e1e; --muted:#aaa; --accent:#00bfff;
    }
    body { font-family: Arial, Helvetica, sans-serif; margin:0; padding:20px; background:var(--bg); color:#fff; }
    h1 { text-align:center; margin-bottom:18px; color:var(--accent); }
    .form-row { display:flex; gap:10px; margin-bottom:12px; flex-wrap:wrap; }
    input, textarea { width:100%; padding:10px; border:none; border-radius:8px; font-size:15px; }
    input { background:#1f1f1f; color:#fff; }
    textarea { background:#1f1f1f; color:#fff; resize:vertical; }
    #summary{height:110px} #consignes{height:120px}
    .btn-row{display:flex; gap:10px; flex-wrap:wrap; margin-bottom:12px;}
    button{background:#007bff;border:none;border-radius:8px;color:#fff;padding:10px 14px;font-size:15px;cursor:pointer}
    button:hover{opacity:.95}
    button.warn{background:#dc3545}
    button.modify{background:#ffc107;color:#000}
    #result { margin-top:14px; padding:18px; background:var(--card); border-radius:10px; line-height:1.6; }
    .signature{margin-top:10px;font-size:13px;color:var(--muted); text-align:right}
    #history{margin-top:18px;padding:12px;background:#151515;border-radius:8px}
    #history h2{margin:0 0 8px 0;color:#ffcc00}
    #history ul{list-style:none;padding:0;margin:0}
    #history li{padding:8px;margin:6px 0;background:#2a2a2a;border-radius:6px;cursor:pointer}
    #history li:hover{background:#3a3a3a}
    /* Styles pour les types de contenu */
    .dialogue { color: #1e90ff; display:block; margin:6px 0; }
    .proverbe { color: #ff4444; display:block; margin:6px 0; }
    .poeme { color: #ff69b4; display:block; margin:6px 0; font-style:italic; }
    .bible { color: #ffcc00; font-weight:700; display:block; margin:6px 0; }
    /* Titres episodes */
    #result h2{color:#00bfff;margin:0 0 6px 0}
    #result h3{color:#00bfff;margin:6px 0 12px 0}
    /* small screen spacing */
    @media (max-width:520px){
      .form-row{flex-direction:column}
    }
  </style>
</head>
<body>
  <h1>üìñ G√©n√©rateur d‚Äôhistoires ‚Äì Kouam√© AI</h1>

  <div class="form-row">
    <input id="title" type="text" placeholder="Titre de l‚Äôhistoire">
    <input id="episode" type="number" placeholder="√âpisode">
    <input id="author" type="text" placeholder="Auteur">
  </div>

  <label for="summary">R√©sum√© de base (personnages / univers) :</label>
  <textarea id="summary" placeholder="D√©cris personnages & contexte..."></textarea>

  <label for="consignes">Consignes / Modifications :</label>
  <textarea id="consignes" placeholder="√âcris ici ce que tu veux ajouter/modifier..."></textarea>

  <div class="btn-row">
    <button id="genBtn" onclick="generateStory()">ü™Ñ G√©n√©rer</button>
    <input id="minWords" type="number" placeholder="N (mots min)" style="width:120px;background:#1f1f1f;color:#fff;padding:10px;border-radius:8px;border:none">
    <button onclick="nextEpisode()">√âpisode suivant</button>
    <button onclick="editEpisode()" class="modify">‚úèÔ∏è Modifier √©pisode</button>
    <button onclick="styleStory()">S (style)</button>
    <button onclick="resetStory()" class="warn">üîÑ R√©initialiser</button>
  </div>

  <div id="result"></div>

  <div id="history">
    <h2>üìö Historique des √©pisodes</h2>
    <ul id="historyList"></ul>
    <div style="margin-top:10px">
      <button onclick="exportPDF()" style="background:#28a745">üì• Exporter en PDF</button>
    </div>
  </div>

  <script>
  // ---------- Variables ----------
  const resultDiv = document.getElementById('result');
  const historyList = document.getElementById('historyList');
  let storyHistory = []; // array of {title, episode, rawText, formattedText, content}
  let currentEpisodeIndex = -1; // index in storyHistory currently displayed/selected

  // ---------- Helpers ----------
  function saveData(){
    const data = {
      title: document.getElementById('title').value || '',
      episode: document.getElementById('episode').value || '',
      author: document.getElementById('author').value || '',
      summary: document.getElementById('summary').value || '',
      history: storyHistory
    };
    localStorage.setItem('storyData', JSON.stringify(data));
  }

  function loadData(){
    const saved = localStorage.getItem('storyData');
    if(!saved) return;
    try{
      const d = JSON.parse(saved);
      document.getElementById('title').value = d.title || '';
      document.getElementById('episode').value = d.episode || '';
      document.getElementById('author').value = d.author || '';
      document.getElementById('summary').value = d.summary || '';
      storyHistory = d.history || [];
      // ensure items have formattedText/content (backwards compat)
      storyHistory = storyHistory.map(ep => {
        if(!ep.formattedText && ep.rawText) ep.formattedText = formatStoryText(ep.rawText);
        if(!ep.content && ep.formattedText) ep.content = buildFullContent(ep);
        return ep;
      });
      renderHistory();
      if(storyHistory.length>0){
        displayEpisode(storyHistory.length-1);
      }
    }catch(e){
      console.error('loadData error',e);
    }
  }

  // Nettoie une string en supprimant balises HTML (pour PDF/export)
  function stripHtml(html){
    const tmp = document.createElement('div');
    tmp.innerHTML = html;
    return tmp.textContent || tmp.innerText || '';
  }

  function buildFullContent(ep){
    const title = ep.title || document.getElementById('title').value || 'Mon Histoire';
    const author = document.getElementById('author').value || 'Inconnu';
    return `<h2>${title}</h2><h3>√âpisode ${ep.episode}</h3><div>${ep.formattedText}</div><div class="signature">Auteur : ${author}<br>D√©veloppeur : Sossou Kouam√©</div>`;
  }

  // Extrait la derni√®re phrase du texte brut (raw)
  function extractLastSentence(raw){
    if(!raw) return '';
    const t = raw.trim();
    // split on end punctuation followed by whitespace (supports newline)
    const parts = t.split(/(?<=[.!?])\s+/);
    for(let i=parts.length-1;i>=0;i--){
      const s = parts[i].trim();
      if(s) return s;
    }
    // fallback: whole text
    return t;
  }

  // ---------- Formatage pour affichage (HTML) ----------
  function formatStoryText(text){
    if(!text) return '';
    // 1) Normalize dashes (‚Äî, ‚Äì) -> hyphen
    let s = text.replace(/‚Äî|‚Äì/g, '-');

    // 2) Force dialogues on their own lines: convert " - " in-line to newline + "- "
    // First ensure hyphens that are meant as dialogue have a preceding space or start of line
    s = s.replace(/\r\n/g, '\n');
    // insert newline before any " - " that is preceded by something that's not a newline (so it becomes its own line)
    s = s.replace(/([^\n])\s-\s/g, '$1\n- ');

    // Also ensure any occurrence of "\n- " stays as is (dialogue start)
    // 3) Replace dialogues starting with '-' to span.dialogue (line by line)
    // We'll split lines and process them individually
    const lines = s.split('\n');
    for(let i=0;i<lines.length;i++){
      let line = lines[i].trim();
      // Proverbe: ¬´ ... ¬ª
      line = line.replace(/¬´([\s\S]*?)¬ª/g, '<span class="proverbe">¬´$1¬ª</span>');
      // Poeme: [poeme]...[/poeme]
      line = line.replace(/\[poeme\]([\s\S]*?)\[\/poeme\]/g, '<span class="poeme">$1</span>');
      // Bible: [bible]...[/bible]
      line = line.replace(/\[bible\]([\s\S]*?)\[\/bible\]/g, '<span class="bible">$1</span>');
      // Dialogue lines beginning with '- '
      if(/^-\s*/.test(line)){
        // keep the - and content inside span.dialogue
        const content = line.replace(/^-+\s*/, '');
        line = `<span class="dialogue">- ${content}</span>`;
      }
      // assign back
      lines[i] = line;
    }
    let result = lines.join('<br>');
    // 4) Add spacing after sentence-ending punctuation for readability (but avoid over-inserting inside spans)
    // small safe replacement: replace punctuation followed by two or more spaces/newline -> add <br><br>
    result = result.replace(/([.!?])(\s+)/g, '$1<br><br>');
    // Trim accidental leading/trailing breaks
    result = result.replace(/^(<br>)+|(<br>)+$/g, '');
    return result.trim();
  }

  // ---------- Rendu historique ----------
  function renderHistory(){
    historyList.innerHTML = '';
    storyHistory.forEach((ep, idx) => {
      const li = document.createElement('li');
      li.textContent = `${ep.title || document.getElementById('title').value || 'Histoire'} ‚Äì √âpisode ${ep.episode}`;
      li.onclick = () => displayEpisode(idx);
      historyList.appendChild(li);
    });
    saveData();
  }

  function displayEpisode(idx){
    const ep = storyHistory[idx];
    if(!ep) return;
    currentEpisodeIndex = idx;
    resultDiv.innerHTML = buildFullContent(ep);
  }

  // ---------- Ajouter √©pisode localement ----------
  function addEpisodeToHistory({title, episode, rawText}){
    const formattedText = formatStoryText(rawText);
    const item = {
      title: title,
      episode: parseInt(episode,10),
      rawText: rawText,
      formattedText: formattedText,
      content: '' // will be set next
    };
    item.content = buildFullContent(item);
    storyHistory.push(item);
    renderHistory();
    displayEpisode(storyHistory.length-1);
  }

  // ---------- Appels √† l'IA (stream) ----------
  async function callAI_stream(prompt, onChunk){
    // envoie le prompt √† ton backend /ask qui doit streamer le texte (comme pr√©c√©demment)
    // onChunk(chunkText) est appel√© √† chaque morceau
    const res = await fetch('/ask', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({ data: "", question: prompt })
    });
    if(!res.ok) {
      const text = await res.text();
      throw new Error('Erreur API: '+text);
    }
    const reader = res.body.getReader();
    const decoder = new TextDecoder();
    let raw = '';
    while(true){
      const {done, value} = await reader.read();
      if(done) break;
      raw += decoder.decode(value, {stream:true});
      if(onChunk) onChunk(raw);
    }
    // last flush (ensure we return final raw)
    return raw;
  }

  // ---------- G√©n√©ration √©pisode ----------
  async function generateStory(){
    const title = document.getElementById('title').value.trim();
    const episode = document.getElementById('episode').value.trim();
    const author = document.getElementById('author').value.trim();
    const summary = document.getElementById('summary').value.trim();
    const consignes = document.getElementById('consignes').value.trim();
    const minWords = document.getElementById('minWords').value.trim();

    if(!title || !episode || !author){
      alert('Veuillez remplir Titre, √âpisode et Auteur !'); return;
    }

    // build context prompt
    let context = `Titre : ${title}\n√âpisode ${episode}\nAuteur : ${author}\n\nR√©sum√© initial : ${summary}\n\n`;
    // instructions strictes
    context += `R√®gles strictes (√† respecter mot pour mot) :\n`;
    context += `1) Ne commence JAMAIS un √©pisode par : "Le lendemain", "Deux mois plus tard", "De l'autre c√¥t√© de la ville", ou √©quivalents temporels/lieux vagues en t√™te d'√©pisode.\n`;
    context += `2) Si ce n'est pas le premier √©pisode, LE NOUVEL √âPISODE DOIT COMMENCER EXACTEMENT par la DERNIERE PHRASE du dernier √©pisode pr√©c√©dent (phrase mot pour mot). Ne r√©p√®te pas d'anciens √©pisodes.\n`;
    context += `3) Le texte doit contenir : dialogues (d√©but de ligne avec '-'), actions entre personnages, au moins un proverbe entre guillemets fran√ßais ¬´ ‚Ä¶ ¬ª OU un po√®me encadr√© par [poeme]...[/poeme] OU une le√ßon / r√©f√©rence biblique encadr√©e par [bible]...[/bible] (au moins une des cat√©gories pr√©sentes).\n`;
    context += `4) L'histoire doit progresser : change le temps (heures/jours/mois), change les lieux, introduis des √©v√©nements ou personnages nouveaux, alterne acc√©l√©rations et ralentissements quand n√©cessaire.\n`;
    context += `5) Termine l'√©pisode sur une ouverture, tension ou suspens pour inciter la lecture du suivant.\n`;
    context += `6) Ne r√©√©cris pas le titre ni le num√©ro d'√©pisode.\n`;

    if(minWords) context += `‚ö†Ô∏è Minimum ${minWords} mots.\n`;
    if(consignes) context += `Consignes additionnelles pour cet √©pisode : ${consignes}\n`;

    // si episode > 1 -> ajouter la phrase d'accroche exacte
    if(storyHistory.length > 0){
      // take last episode rawText (the latest stored raw)
      const lastEpRaw = storyHistory[storyHistory.length - 1].rawText || '';
      const lastSentence = extractLastSentence(lastEpRaw);
      if(lastSentence){
        context += `\n‚ö†Ô∏è IMPORTANT : Le nouvel √©pisode DOIT commencer EXACTEMENT par cette phrase (copie mot pour mot) :\n"${lastSentence}"\n\nEnsuite, continue naturellement la suite.\n`;
      }
    }

    // Affichage pendant g√©n√©ration
    resultDiv.innerHTML = `<h2>${title}</h2><h3>√âpisode ${episode}</h3><div style="opacity:0.9">‚è≥ Kouam√© AI r√©fl√©chit‚Ä¶</div>`;

    try{
      // stream, update display as raw grows
      const rawFinal = await callAI_stream(context, (rawSoFar) => {
        // affiche format√© en direct (gentil)
        const formatted = formatStoryText(rawSoFar);
        resultDiv.innerHTML = `<h2>${title}</h2><h3>√âpisode ${episode}</h3><div>${formatted}</div><div class="signature">Auteur : ${author}<br>D√©veloppeur : Sossou Kouam√©</div>`;
      });

      // final store (use rawFinal as raw text)
      addEpisodeToHistory({ title, episode, rawText: rawFinal });

      // clear consignes
      document.getElementById('consignes').value = '';
    }catch(err){
      console.error(err);
      alert('Erreur lors de la g√©n√©ration : ' + (err.message || err));
    }
  }

  // ---------- Edit episode ----------
  async function editEpisode(){
    const episodeNumber = parseInt(document.getElementById('episode').value, 10);
    const consignes = document.getElementById('consignes').value.trim();
    const title = document.getElementById('title').value.trim() || 'Histoire';
    const author = document.getElementById('author').value.trim() || 'Auteur';

    if(!episodeNumber || isNaN(episodeNumber)){ alert('Renseigne le num√©ro d\'√©pisode √† modifier dans le champ √âpisode.'); return; }
    if(!consignes){ alert('√âcris tes consignes de modification dans la zone "Consignes".'); return; }

    const idx = storyHistory.findIndex(e => e.episode === episodeNumber);
    if(idx === -1){ alert("√âpisode introuvable dans l'historique."); return; }

    // build edit prompt
    let editPrompt = `Voici le texte ORIGINAL de l'√©pisode ${episodeNumber} :\n\n${storyHistory[idx].rawText}\n\n`;
    editPrompt += `Consignes de modification (applique uniquement ces changements) : ${consignes}\n\n`;
    editPrompt += `R√®gles :\n- N'ajoute pas de titre ni de num√©ro d'√©pisode.\n- Applique uniquement corrections demand√©es (ajout/suppression/modification de phrases/√©v√©nements).\n`;
    // si ce n'est pas le premier √©pisode, pr√©ciser qu'il doit commencer par la derni√®re phrase de l'√©pisode pr√©c√©dent
    if(idx > 0){
      const prevLast = extractLastSentence(storyHistory[idx-1].rawText);
      if(prevLast) editPrompt += `- IMPORTANT : cet √©pisode (n¬∞${episodeNumber}) doit commencer EXACTEMENT par la phrase suivante (mot pour mot) : "${prevLast}".\n`;
    }
    editPrompt += `\nRenvoie seulement le texte modifi√© de l'√©pisode.\n`;

    resultDiv.innerHTML = `<div style="opacity:0.9">‚úèÔ∏è Application des modifications‚Ä¶</div>`;

    try{
      const modifiedRaw = await callAI_stream(editPrompt, (partial) => {
        // show live
        const formatted = formatStoryText(partial);
        resultDiv.innerHTML = `<h2>${title}</h2><h3>√âpisode ${episodeNumber} (√©dition)</h3><div>${formatted}</div><div class="signature">Auteur : ${author}<br>D√©veloppeur : Sossou Kouam√©</div>`;
      });

      // update the episode in history (raw & formatted)
      storyHistory[idx].rawText = modifiedRaw;
      storyHistory[idx].formattedText = formatStoryText(modifiedRaw);
      storyHistory[idx].content = buildFullContent(storyHistory[idx]);

      // If we modified an episode, subsequent episodes should remain but when you generate the next episode,
      // the code will take the updated last sentence. (We don't auto-regenerate subsequent eps.)
      renderHistory();
      displayEpisode(idx);
      document.getElementById('consignes').value = '';
    }catch(err){
      console.error(err);
      alert('Erreur lors de la modification : ' + (err.message || err));
    }
  }

  // ---------- Next episode (increment and generate) ----------
  async function nextEpisode(){
    const epInput = document.getElementById('episode');
    const current = parseInt(epInput.value||'0',10) || 0;
    epInput.value = current + 1;
    await generateStory();
  }

  // ---------- Style story (r√©appliquer style via prompt) ----------
  async function styleStory(){
    // r√©-applique un style via l'IA (optionnel) sur l'√©pisode s√©lectionn√© (ou dernier)
    let episodeNumber = parseInt(document.getElementById('episode').value,10);
    if(isNaN(episodeNumber) || episodeNumber===0){
      if(storyHistory.length===0){ alert('Aucune histoire √† styliser.'); return; }
      episodeNumber = storyHistory[storyHistory.length-1].episode;
    }
    const idx = storyHistory.findIndex(e => e.episode === episodeNumber);
    if(idx === -1){ alert("√âpisode introuvable."); return; }
    const raw = storyHistory[idx].rawText || '';
    const prompt = `R√©√©cris ce texte en conservant le sens, en ajoutant du style (gras, italique, emojis, dialogues sur lignes s√©par√©es) sans changer le titre ni le num√©ro d'√©pisode. Texte :\n\n${raw}\n\nRenvoie seulement le texte stylis√©.`;
    resultDiv.innerHTML = `<div style="opacity:0.9">‚ú® Application du style‚Ä¶</div>`;
    try{
      const styledRaw = await callAI_stream(prompt, (partial) => {
        resultDiv.innerHTML = `<h2>${storyHistory[idx].title}</h2><h3>√âpisode ${episodeNumber} (stylisation)</h3><div>${formatStoryText(partial)}</div>`;
      });
      storyHistory[idx].rawText = styledRaw;
      storyHistory[idx].formattedText = formatStoryText(styledRaw);
      storyHistory[idx].content = buildFullContent(storyHistory[idx]);
      renderHistory(); displayEpisode(idx);
    }catch(err){
      console.error(err);
      alert('Erreur lors de la stylisation : ' + (err.message || err));
    }
  }

  // ---------- Reset ----------
  function resetStory(){
    if(!confirm('Voulez-vous vraiment r√©initialiser l\'histoire et l\'historique ?')) return;
    localStorage.removeItem('storyData');
    document.getElementById('title').value = '';
    document.getElementById('episode').value = '';
    document.getElementById('author').value = '';
    document.getElementById('summary').value = '';
    document.getElementById('consignes').value = '';
    resultDiv.innerHTML = '';
    storyHistory = [];
    renderHistory();
    currentEpisodeIndex = -1;
  }

  // ---------- Export PDF (simple) ----------
  async function exportPDF(){
    if(storyHistory.length===0){ alert('Aucune histoire √† exporter !'); return; }
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF();
    let y = 20;
    const title = document.getElementById('title').value || 'Mon Histoire';
    const author = document.getElementById('author').value || 'Inconnu';
    doc.setFontSize(20);
    doc.text(title, 105, y, {align:'center'}); y+=10;
    doc.setFontSize(12);
    doc.text('Auteur : ' + author, 105, y, {align:'center'}); y+=10;
    doc.setFontSize(11);
    doc.text('---', 20, y); y+=8;
    storyHistory.forEach((ep) => {
      doc.setFontSize(14); 
      doc.text(`√âpisode ${ep.episode}`, 20, y); y+=8;
      doc.setFontSize(11);
      const text = stripHtml(ep.formattedText || ep.rawText || '');
      const lines = doc.splitTextToSize(text, 170);
      lines.forEach(line => {
     
